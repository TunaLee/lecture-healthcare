<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python 자료구조: Linked List, Stack & Queue</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        .container {
            width: 100%;
            height: 100vh;
            background: white;
            display: flex;
            flex-direction: column;
        }

        #slidesContainer {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 20px;
        }

        /* 커스텀 스크롤바 */
        #slidesContainer::-webkit-scrollbar {
            width: 10px;
        }

        #slidesContainer::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        #slidesContainer::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 5px;
        }

        #slidesContainer::-webkit-scrollbar-thumb:hover {
            background: #5568d3;
        }

        .slide {
            padding: 60px;
            min-height: auto;
            display: none;
        }

        .slide.active {
            display: block;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        h1 {
            font-size: 48px;
            color: #667eea;
            margin-bottom: 10px;
            text-align: center;
        }

        h2 {
            font-size: 36px;
            color: #333;
            margin-bottom: 20px;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        h3 {
            font-size: 24px;
            color: #666;
            margin-bottom: 20px;
        }

        h4 {
            font-size: 20px;
            color: #667eea;
            margin-bottom: 10px;
        }

        p {
            font-size: 18px;
            line-height: 1.6;
            color: #555;
            margin-bottom: 15px;
        }

        .subtitle {
            font-size: 24px;
            color: #888;
            text-align: center;
            margin-bottom: 40px;
        }

        .box {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #667eea;
            margin-bottom: 15px;
        }

        .comparison-box {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .success-box {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .warning-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .example-box {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .danger-box {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .center-text {
            text-align: center;
            font-size: 20px;
            margin: 30px 0;
        }

        .formula {
            background: #2c3e50;
            color: white;
            padding: 20px;
            border-radius: 10px;
            font-size: 20px;
            text-align: center;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
        }

        ul, ol {
            margin-left: 30px;
            margin-bottom: 15px;
        }

        li {
            font-size: 18px;
            line-height: 1.8;
            color: #555;
            margin-bottom: 8px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border: 1px solid #ddd;
        }

        th {
            background: #667eea;
            color: white;
            font-weight: bold;
        }

        tr:nth-child(even) {
            background: #f8f9fa;
        }

        code {
            background: #2c3e50;
            color: #ffd93d;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }

        pre {
            background: #2c3e50;
            color: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            overflow-x: auto;
            margin: 15px 0;
        }

        pre code {
            background: none;
            color: inherit;
            padding: 0;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 40px;
            background: #f8f9fa;
            border-top: 2px solid #e0e0e0;
            flex-shrink: 0;
            position: sticky;
            bottom: 0;
            z-index: 100;
        }

        .navigation {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .page-jump {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            opacity: 0.6;
        }

        input[type="number"] {
            padding: 8px 12px;
            border: 2px solid #667eea;
            border-radius: 5px;
            font-size: 16px;
            width: 80px;
            text-align: center;
        }

        .slide-counter {
            font-size: 18px;
            font-weight: bold;
            color: #667eea;
        }

        .visualization-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 30px 0;
            min-height: 300px;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin: 20px 0;
        }

        .grid-container-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 20px 0;
        }

        .data-card {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 20px;
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .data-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .node-box {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            margin: 0 10px;
            position: relative;
        }

        .arrow {
            display: inline-block;
            width: 40px;
            height: 2px;
            background: #667eea;
            position: relative;
            margin: 0 5px;
        }

        .arrow::after {
            content: '';
            position: absolute;
            right: 0;
            top: -4px;
            width: 0;
            height: 0;
            border-left: 10px solid #667eea;
            border-top: 5px solid transparent;
            border-bottom: 5px solid transparent;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="slidesContainer"></div>
        <div class="controls">
            <button id="prevBtn">이전</button>
            <div class="navigation">
                <span class="slide-counter">
                    <span id="currentSlide">1</span> / <span id="totalSlides">0</span>
                </span>
                <div class="page-jump">
                    <input type="number" id="pageInput" min="1" placeholder="페이지">
                    <button id="jumpBtn">이동</button>
                </div>
            </div>
            <button id="nextBtn">다음</button>
        </div>
    </div>

    <script>
        const slidesHTML = `
<h1>Python 자료구조 마스터하기</h1>
<p class="subtitle">Object-Oriented Programming과 Linked List, Stack & Queue</p>
<div class="box">
<h4>수업 목표</h4>
<p>자료구조의 개념과 필요성을 이해한다</p>
<p>Python의 객체지향 프로그래밍을 활용한 자료구조 구현</p>
<p>Linked List의 원리와 구현 방법을 학습한다</p>
<p>Stack과 Queue의 동작 원리를 시각적으로 이해한다</p>
<p>실제 문제 해결에 적절한 자료구조를 선택하고 활용할 수 있다</p>
</div>
<div class="center-text">
<p>프로그래밍의 핵심, 자료구조의 세계로 들어가봅시다!</p>
</div>
===SPLIT===
<h2>자료구조란 무엇인가?</h2>
<h3>Data Structure의 정의와 개념</h3>
<div class="box">
<h4>자료구조의 정의</h4>
<p><strong>자료구조(Data Structure)</strong>는 데이터를 효율적으로 저장하고 관리하는 방법입니다.</p>
<p>컴퓨터 메모리에 데이터를 체계적으로 정리하여 필요할 때 빠르게 찾고 사용할 수 있도록 하는 구조입니다.</p>
</div>
<div class="example-box">
<h4>일상생활의 자료구조 예시</h4>
<p><strong>도서관:</strong> 책을 분류 체계에 따라 정리 (카테고리별, 저자별)</p>
<p><strong>전화번호부:</strong> 이름을 알파벳 순서로 정렬</p>
<p><strong>옷장:</strong> 종류별, 계절별로 옷을 정리</p>
<p><strong>식당 대기 줄:</strong> 먼저 온 사람이 먼저 들어가는 구조 (FIFO)</p>
</div>
<div class="comparison-box">
<div class="success-box">
<h4>자료구조를 사용할 때</h4>
<p>검색 속도가 빠름</p>
<p>메모리 효율적 사용</p>
<p>데이터 관리가 체계적</p>
<p>코드 가독성 향상</p>
</div>
<div class="danger-box">
<h4>자료구조 없이 프로그래밍할 때</h4>
<p>데이터 검색이 느림</p>
<p>메모리 낭비 발생</p>
<p>코드가 복잡해짐</p>
<p>유지보수가 어려움</p>
</div>
</div>
===SPLIT===
<h2>왜 자료구조가 필요한가?</h2>
<h3>효율성과 성능의 관점에서</h3>
<div class="box">
<h4>성능 비교 예시: 100만 개 데이터에서 특정 값 찾기</h4>
<table>
<tr>
<th>방법</th>
<th>시간 복잡도</th>
<th>예상 소요 시간</th>
<th>설명</th>
</tr>
<tr>
<td>리스트 순차 검색</td>
<td>O(n)</td>
<td>평균 500,000번 비교</td>
<td>처음부터 끝까지 확인</td>
</tr>
<tr>
<td>정렬된 리스트 이진 검색</td>
<td>O(log n)</td>
<td>최대 20번 비교</td>
<td>중간값과 비교하며 범위를 반으로 줄임</td>
</tr>
<tr>
<td>해시 테이블</td>
<td>O(1)</td>
<td>평균 1번 접근</td>
<td>키를 통한 직접 접근</td>
</tr>
</table>
</div>
<div class="warning-box">
<h4>실제 성능 차이 예시</h4>
<pre><code># 리스트에서 값 찾기 (비효율적)
data = list(range(1000000))
target = 999999

# 순차 검색: 약 0.05초
for item in data:
    if item == target:
        break

# vs 집합(Set) 사용: 약 0.00001초
data_set = set(data)
if target in data_set:
    pass</code></pre>
</div>
<div class="success-box">
<h4>자료구조 선택의 중요성</h4>
<p><strong>작업의 특성 고려:</strong> 삽입/삭제가 많은가? 검색이 많은가?</p>
<p><strong>데이터의 크기:</strong> 소량? 대량?</p>
<p><strong>메모리 제약:</strong> 공간 효율성이 중요한가?</p>
<p><strong>순서 유지:</strong> 데이터의 순서가 중요한가?</p>
</div>
===SPLIT===
<h2>기본 자료구조 유형</h2>
<h3>선형 vs 비선형 자료구조</h3>
<div class="grid-container">
<div class="data-card">
<h4>선형 자료구조 (Linear)</h4>
<p>데이터가 순차적으로 연결된 구조</p>
<ul>
<li><strong>배열(Array):</strong> 고정 크기, 인덱스 접근</li>
<li><strong>연결 리스트(Linked List):</strong> 동적 크기, 순차 접근</li>
<li><strong>스택(Stack):</strong> LIFO (Last In First Out)</li>
<li><strong>큐(Queue):</strong> FIFO (First In First Out)</li>
</ul>
</div>
<div class="data-card">
<h4>비선형 자료구조 (Non-linear)</h4>
<p>데이터가 계층적 또는 망 형태로 연결</p>
<ul>
<li><strong>트리(Tree):</strong> 계층적 구조</li>
<li><strong>그래프(Graph):</strong> 노드와 간선으로 연결</li>
<li><strong>힙(Heap):</strong> 완전 이진 트리</li>
<li><strong>해시 테이블(Hash Table):</strong> 키-값 쌍</li>
</ul>
</div>
</div>
<div class="example-box">
<h4>Python 내장 자료구조</h4>
<pre><code># List - 동적 배열
numbers = [1, 2, 3, 4, 5]

# Tuple - 불변 리스트
coordinates = (10, 20)

# Set - 중복 없는 집합
unique_items = {1, 2, 3, 3, 4}  # {1, 2, 3, 4}

# Dictionary - 키-값 쌍
person = {"name": "김철수", "age": 25}

# Deque - 양방향 큐
from collections import deque
queue = deque([1, 2, 3])</code></pre>
</div>
===SPLIT===
<h2>Stack 자료구조</h2>
<h3>LIFO (Last In First Out) 구조의 이해</h3>
<div class="box">
<h4>Stack이란?</h4>
<p><strong>Stack</strong>은 마지막에 들어온 데이터가 먼저 나가는 LIFO 구조입니다.</p>
<p>책을 쌓아올리는 것처럼, 위에서만 추가하고 제거할 수 있습니다.</p>
</div>
<div class="visualization-container">
<div style="text-align: center;">
<div style="display: inline-block; vertical-align: bottom;">
<div style="width: 150px; margin: 0 auto;">
<div style="border: 3px solid #667eea; border-bottom: 3px solid #667eea; padding: 0; background: white;">
<div style="background: #e7f3ff; border: 1px solid #2196F3; margin: 2px; padding: 15px; text-align: center;">TOP → 30</div>
<div style="background: #f8f9fa; border: 1px solid #ddd; margin: 2px; padding: 15px; text-align: center;">20</div>
<div style="background: #f8f9fa; border: 1px solid #ddd; margin: 2px; padding: 15px; text-align: center;">10</div>
<div style="background: #f8f9fa; border: 1px solid #ddd; margin: 2px; padding: 15px; text-align: center;">5</div>
</div>
</div>
<p style="margin-top: 10px; color: #667eea; font-weight: bold;">Stack</p>
</div>
<div style="display: inline-block; margin: 0 50px;">
<div style="text-align: left;">
<p><strong>Push(40):</strong> 맨 위에 40 추가</p>
<p><strong>Pop():</strong> 30 제거 및 반환</p>
<p><strong>Peek():</strong> 30 확인 (제거X)</p>
<p><strong>isEmpty():</strong> 비어있는지 확인</p>
</div>
</div>
</div>
</div>
<div class="grid-container">
<div class="success-box">
<h4>Stack 활용 예시</h4>
<p><strong>실행 취소 (Undo):</strong> 가장 최근 작업부터 취소</p>
<p><strong>함수 호출 스택:</strong> 재귀 함수 관리</p>
<p><strong>괄호 매칭:</strong> ({[]}) 검증</p>
<p><strong>브라우저 뒤로가기:</strong> 방문 기록 관리</p>
<p><strong>수식 계산:</strong> 후위 표기법 계산</p>
</div>
<div class="example-box">
<h4>Python Stack 구현</h4>
<pre><code>class Stack:
    def __init__(self):
        self.items = []
    
    def push(self, item):
        self.items.append(item)  # O(1)
    
    def pop(self):
        if not self.is_empty():
            return self.items.pop()  # O(1)
        return None
    
    def peek(self):
        if not self.is_empty():
            return self.items[-1]
        return None
    
    def is_empty(self):
        return len(self.items) == 0
    
    def size(self):
        return len(self.items)</code></pre>
</div>
</div>
===SPLIT===
<h2>Queue 자료구조</h2>
<h3>FIFO (First In First Out) 구조의 이해</h3>
<div class="box">
<h4>Queue란?</h4>
<p><strong>Queue</strong>는 먼저 들어온 데이터가 먼저 나가는 FIFO 구조입니다.</p>
<p>줄을 서는 것처럼, 뒤에서 들어와서 앞에서 나갑니다.</p>
</div>
<div class="visualization-container">
<div style="text-align: center;">
<div style="display: inline-block;">
<div style="display: flex; align-items: center;">
<div style="padding: 10px; color: #667eea; font-weight: bold;">Enqueue →</div>
<div style="display: flex; border: 3px solid #667eea; background: white;">
<div style="background: #f8f9fa; border-right: 1px solid #ddd; padding: 20px 30px; text-align: center;">40</div>
<div style="background: #f8f9fa; border-right: 1px solid #ddd; padding: 20px 30px; text-align: center;">30</div>
<div style="background: #f8f9fa; border-right: 1px solid #ddd; padding: 20px 30px; text-align: center;">20</div>
<div style="background: #e7f3ff; border: none; padding: 20px 30px; text-align: center; font-weight: bold;">10</div>
</div>
<div style="padding: 10px; color: #667eea; font-weight: bold;">→ Dequeue</div>
</div>
<div style="margin-top: 10px;">
<span style="color: #888;">Rear (뒤)</span>
<span style="margin: 0 100px;">←── Queue ──→</span>
<span style="color: #888;">Front (앞)</span>
</div>
</div>
</div>
</div>
<div class="grid-container">
<div class="warning-box">
<h4>Queue 활용 예시</h4>
<p><strong>프린터 대기열:</strong> 먼저 요청한 순서대로 인쇄</p>
<p><strong>프로세스 스케줄링:</strong> CPU 작업 관리</p>
<p><strong>BFS 알고리즘:</strong> 너비 우선 탐색</p>
<p><strong>메시지 큐:</strong> 비동기 통신</p>
<p><strong>대기 시스템:</strong> 은행, 병원 번호표</p>
</div>
<div class="example-box">
<h4>Python Queue 구현</h4>
<pre><code>from collections import deque

class Queue:
    def __init__(self):
        self.items = deque()
    
    def enqueue(self, item):
        self.items.append(item)  # O(1)
    
    def dequeue(self):
        if not self.is_empty():
            return self.items.popleft()  # O(1)
        return None
    
    def front(self):
        if not self.is_empty():
            return self.items[0]
        return None
    
    def is_empty(self):
        return len(self.items) == 0
    
    def size(self):
        return len(self.items)</code></pre>
</div>
</div>
===SPLIT===
<h2>Stack vs Queue 비교</h2>
<h3>두 자료구조의 차이점과 활용</h3>
<table>
<tr>
<th>특징</th>
<th>Stack (스택)</th>
<th>Queue (큐)</th>
</tr>
<tr>
<td>구조</td>
<td>LIFO (Last In First Out)</td>
<td>FIFO (First In First Out)</td>
</tr>
<tr>
<td>삽입 위치</td>
<td>Top (맨 위)</td>
<td>Rear (뒤)</td>
</tr>
<tr>
<td>삭제 위치</td>
<td>Top (맨 위)</td>
<td>Front (앞)</td>
</tr>
<tr>
<td>주요 연산</td>
<td>push(), pop(), peek()</td>
<td>enqueue(), dequeue(), front()</td>
</tr>
<tr>
<td>시간 복잡도</td>
<td>모든 연산 O(1)</td>
<td>모든 연산 O(1)</td>
</tr>
<tr>
<td>Python 구현</td>
<td>list 사용 가능</td>
<td>collections.deque 권장</td>
</tr>
</table>
<div class="visualization-container">
<div style="display: flex; justify-content: space-around; align-items: flex-start;">
<div style="text-align: center;">
<h4 style="color: #667eea;">Stack 동작</h4>
<div style="border: 2px solid #667eea; width: 100px; padding: 10px; background: white;">
<div style="margin: 5px 0;">↓ Push</div>
<div style="background: #e7f3ff; margin: 2px; padding: 10px;">3</div>
<div style="background: #f8f9fa; margin: 2px; padding: 10px;">2</div>
<div style="background: #f8f9fa; margin: 2px; padding: 10px;">1</div>
<div style="margin: 5px 0;">↑ Pop</div>
</div>
<p>같은 곳에서 입출력</p>
</div>
<div style="text-align: center;">
<h4 style="color: #667eea;">Queue 동작</h4>
<div style="display: flex; align-items: center;">
<div>Enqueue →</div>
<div style="border: 2px solid #667eea; display: flex; background: white;">
<div style="background: #f8f9fa; padding: 10px 15px; margin: 2px;">3</div>
<div style="background: #f8f9fa; padding: 10px 15px; margin: 2px;">2</div>
<div style="background: #e7f3ff; padding: 10px 15px; margin: 2px;">1</div>
</div>
<div>→ Dequeue</div>
</div>
<p>다른 곳에서 입출력</p>
</div>
</div>
</div>
===SPLIT===
<h2>Stack 동작 시각화</h2>
<h3>Push와 Pop 연산의 단계별 과정</h3>
<div class="box">
<h4>Stack Push 연산 과정</h4>
<div style="display: flex; justify-content: space-around; margin: 20px 0;">
<div style="text-align: center;">
<p style="color: #667eea; font-weight: bold;">초기 상태</p>
<div style="border: 3px solid #667eea; width: 100px; padding: 10px; background: white; min-height: 150px;">
<div style="background: #f8f9fa; margin: 2px; padding: 10px;">10</div>
<div style="background: #f8f9fa; margin: 2px; padding: 10px;">5</div>
</div>
<p>Stack</p>
</div>
<div style="text-align: center;">
<p style="color: #667eea; font-weight: bold;">Push(20)</p>
<div style="border: 3px solid #667eea; width: 100px; padding: 10px; background: white; min-height: 150px;">
<div style="background: #ffd93d; margin: 2px; padding: 10px; border: 2px solid #ffc107;">20</div>
<div style="background: #f8f9fa; margin: 2px; padding: 10px;">10</div>
<div style="background: #f8f9fa; margin: 2px; padding: 10px;">5</div>
</div>
<p>새 요소 추가</p>
</div>
<div style="text-align: center;">
<p style="color: #667eea; font-weight: bold;">결과</p>
<div style="border: 3px solid #667eea; width: 100px; padding: 10px; background: white; min-height: 150px;">
<div style="background: #e7f3ff; margin: 2px; padding: 10px;">20</div>
<div style="background: #f8f9fa; margin: 2px; padding: 10px;">10</div>
<div style="background: #f8f9fa; margin: 2px; padding: 10px;">5</div>
</div>
<p>Top = 20</p>
</div>
</div>
</div>
<div class="box">
<h4>Stack Pop 연산 과정</h4>
<div style="display: flex; justify-content: space-around; margin: 20px 0;">
<div style="text-align: center;">
<p style="color: #667eea; font-weight: bold;">초기 상태</p>
<div style="border: 3px solid #667eea; width: 100px; padding: 10px; background: white; min-height: 150px;">
<div style="background: #e7f3ff; margin: 2px; padding: 10px;">30</div>
<div style="background: #f8f9fa; margin: 2px; padding: 10px;">20</div>
<div style="background: #f8f9fa; margin: 2px; padding: 10px;">10</div>
</div>
<p>Top = 30</p>
</div>
<div style="text-align: center;">
<p style="color: #667eea; font-weight: bold;">Pop()</p>
<div style="border: 3px solid #667eea; width: 100px; padding: 10px; background: white; min-height: 150px;">
<div style="background: #ffcdd2; margin: 2px; padding: 10px; border: 2px solid #dc3545; text-decoration: line-through;">30</div>
<div style="background: #f8f9fa; margin: 2px; padding: 10px;">20</div>
<div style="background: #f8f9fa; margin: 2px; padding: 10px;">10</div>
</div>
<p>반환: 30</p>
</div>
<div style="text-align: center;">
<p style="color: #667eea; font-weight: bold;">결과</p>
<div style="border: 3px solid #667eea; width: 100px; padding: 10px; background: white; min-height: 150px;">
<div style="background: #e7f3ff; margin: 2px; padding: 10px;">20</div>
<div style="background: #f8f9fa; margin: 2px; padding: 10px;">10</div>
</div>
<p>Top = 20</p>
</div>
</div>
</div>
===SPLIT===
<h2>Queue 동작 시각화</h2>
<h3>Enqueue와 Dequeue 연산의 단계별 과정</h3>
<div class="box">
<h4>Queue Enqueue 연산 과정</h4>
<div style="margin: 30px 0;">
<div style="text-align: center; margin-bottom: 20px;">
<p style="color: #667eea; font-weight: bold;">초기 상태</p>
<div style="display: inline-flex; align-items: center; border: 3px solid #667eea; background: white; padding: 10px;">
<div style="background: #f8f9fa; padding: 15px 25px; margin: 2px;">10</div>
<div style="background: #f8f9fa; padding: 15px 25px; margin: 2px;">20</div>
</div>
<p>Front = 10, Rear = 20</p>
</div>
<div style="text-align: center; margin-bottom: 20px;">
<p style="color: #667eea; font-weight: bold;">Enqueue(30)</p>
<div style="display: inline-flex; align-items: center; border: 3px solid #667eea; background: white; padding: 10px;">
<div style="background: #f8f9fa; padding: 15px 25px; margin: 2px;">10</div>
<div style="background: #f8f9fa; padding: 15px 25px; margin: 2px;">20</div>
<div style="background: #ffd93d; padding: 15px 25px; margin: 2px; border: 2px solid #ffc107;">30</div>
</div>
<p>새 요소를 뒤에 추가</p>
</div>
<div style="text-align: center;">
<p style="color: #667eea; font-weight: bold;">결과</p>
<div style="display: inline-flex; align-items: center; border: 3px solid #667eea; background: white; padding: 10px;">
<div style="background: #e7f3ff; padding: 15px 25px; margin: 2px;">10</div>
<div style="background: #f8f9fa; padding: 15px 25px; margin: 2px;">20</div>
<div style="background: #f8f9fa; padding: 15px 25px; margin: 2px;">30</div>
</div>
<p>Front = 10, Rear = 30</p>
</div>
</div>
</div>
<div class="box">
<h4>Queue Dequeue 연산 과정</h4>
<div style="margin: 30px 0;">
<div style="text-align: center; margin-bottom: 20px;">
<p style="color: #667eea; font-weight: bold;">초기 상태</p>
<div style="display: inline-flex; align-items: center; border: 3px solid #667eea; background: white; padding: 10px;">
<div style="background: #e7f3ff; padding: 15px 25px; margin: 2px;">5</div>
<div style="background: #f8f9fa; padding: 15px 25px; margin: 2px;">15</div>
<div style="background: #f8f9fa; padding: 15px 25px; margin: 2px;">25</div>
</div>
<p>Front = 5, Rear = 25</p>
</div>
<div style="text-align: center; margin-bottom: 20px;">
<p style="color: #667eea; font-weight: bold;">Dequeue()</p>
<div style="display: inline-flex; align-items: center; border: 3px solid #667eea; background: white; padding: 10px;">
<div style="background: #ffcdd2; padding: 15px 25px; margin: 2px; border: 2px solid #dc3545; text-decoration: line-through;">5</div>
<div style="background: #f8f9fa; padding: 15px 25px; margin: 2px;">15</div>
<div style="background: #f8f9fa; padding: 15px 25px; margin: 2px;">25</div>
</div>
<p>반환: 5 (앞에서 제거)</p>
</div>
<div style="text-align: center;">
<p style="color: #667eea; font-weight: bold;">결과</p>
<div style="display: inline-flex; align-items: center; border: 3px solid #667eea; background: white; padding: 10px;">
<div style="background: #e7f3ff; padding: 15px 25px; margin: 2px;">15</div>
<div style="background: #f8f9fa; padding: 15px 25px; margin: 2px;">25</div>
</div>
<p>Front = 15, Rear = 25</p>
</div>
</div>
</div>
===SPLIT===
<h2>Linked List 소개</h2>
<h3>연결 리스트의 개념과 특징</h3>
<div class="box">
<h4>Linked List란?</h4>
<p>노드(Node)들이 포인터로 연결되어 있는 선형 자료구조</p>
<p>각 노드는 <strong>데이터(data)</strong>와 <strong>다음 노드를 가리키는 포인터(next)</strong>로 구성</p>
<p>메모리상에 연속적으로 저장되지 않고, 각 노드가 다음 노드의 주소를 저장</p>
</div>
<div class="visualization-container">
<div style="text-align: center;">
<span class="node-box">10</span>
<span class="arrow"></span>
<span class="node-box">20</span>
<span class="arrow"></span>
<span class="node-box">30</span>
<span class="arrow"></span>
<span class="node-box">40</span>
<span class="arrow"></span>
<span style="display: inline-block; padding: 10px 20px; background: #e0e0e0; border-radius: 5px;">NULL</span>
</div>
</div>
<div class="comparison-box">
<div class="success-box">
<h4>Linked List 장점</h4>
<p><strong>동적 크기:</strong> 실행 중 크기 변경 가능</p>
<p><strong>삽입/삭제 효율:</strong> O(1) - 특정 위치에서</p>
<p><strong>메모리 효율:</strong> 필요한 만큼만 할당</p>
<p><strong>구현 유연성:</strong> 다양한 변형 가능</p>
</div>
<div class="warning-box">
<h4>Linked List 단점</h4>
<p><strong>랜덤 접근 불가:</strong> 인덱스 접근 X</p>
<p><strong>추가 메모리:</strong> 포인터 저장 공간 필요</p>
<p><strong>캐시 성능:</strong> 연속적이지 않아 캐시 효율 낮음</p>
<p><strong>역방향 순회:</strong> 단일 연결 리스트는 어려움</p>
</div>
</div>
===SPLIT===
<h2>Array vs Linked List</h2>
<h3>배열과 연결 리스트의 차이점</h3>
<table>
<tr>
<th>특징</th>
<th>Array (배열)</th>
<th>Linked List (연결 리스트)</th>
</tr>
<tr>
<td>메모리 할당</td>
<td>연속적인 메모리 공간</td>
<td>분산된 메모리 공간</td>
</tr>
<tr>
<td>크기</td>
<td>고정 (Python 리스트는 동적)</td>
<td>동적</td>
</tr>
<tr>
<td>인덱스 접근</td>
<td>O(1) - 직접 접근</td>
<td>O(n) - 순차 탐색 필요</td>
</tr>
<tr>
<td>삽입/삭제 (처음)</td>
<td>O(n) - 모든 요소 이동</td>
<td>O(1) - Head만 변경</td>
</tr>
<tr>
<td>삽입/삭제 (중간)</td>
<td>O(n) - 요소 이동 필요</td>
<td>O(n) - 위치 찾기 + O(1)</td>
</tr>
<tr>
<td>메모리 오버헤드</td>
<td>낮음</td>
<td>높음 (포인터 저장)</td>
</tr>
<tr>
<td>캐시 효율성</td>
<td>높음 (연속적)</td>
<td>낮음 (분산적)</td>
</tr>
</table>
<div class="example-box">
<h4>사용 시나리오</h4>
<p><strong>Array 선택:</strong> 데이터 크기가 고정적, 랜덤 접근이 빈번, 캐시 효율이 중요</p>
<p><strong>Linked List 선택:</strong> 데이터 크기가 가변적, 삽입/삭제가 빈번, 메모리가 제한적</p>
</div>
===SPLIT===
<h2>Linked List 구현 - Node 클래스</h2>
<h3>Python OOP를 활용한 노드 구현</h3>
<div class="box">
<h4>Node 클래스 설계</h4>
<p>노드는 Linked List의 기본 구성 요소입니다</p>
<p>각 노드는 데이터와 다음 노드에 대한 참조를 가집니다</p>
</div>
<div class="example-box">
<h4>Node 클래스 구현</h4>
<pre><code>class Node:
    """Linked List의 노드를 표현하는 클래스"""
    
    def __init__(self, data):
        """
        노드 초기화
        :param data: 노드가 저장할 데이터
        """
        self.data = data  # 노드의 데이터
        self.next = None  # 다음 노드를 가리키는 포인터
    
    def __repr__(self):
        """노드의 문자열 표현"""
        return f"Node({self.data})"
    
    def __str__(self):
        """노드 출력 시 보여질 문자열"""
        return str(self.data)


# 노드 생성 예시
node1 = Node(10)
node2 = Node(20)
node3 = Node(30)

# 노드 연결
node1.next = node2
node2.next = node3

# 노드 순회
current = node1
while current:
    print(current.data, end=" -> ")
    current = current.next
print("None")
# 출력: 10 -> 20 -> 30 -> None</code></pre>
</div>
===SPLIT===
<h2>Linked List 구현 - LinkedList 클래스</h2>
<h3>기본 연산을 포함한 완전한 구현</h3>
<div class="example-box">
<h4>LinkedList 클래스 구현 (1/2)</h4>
<pre><code>class LinkedList:
    """단일 연결 리스트 구현"""
    
    def __init__(self):
        """빈 연결 리스트 초기화"""
        self.head = None  # 첫 번째 노드를 가리키는 포인터
        self.size = 0     # 리스트의 크기
    
    def __len__(self):
        """리스트의 길이 반환"""
        return self.size
    
    def is_empty(self):
        """리스트가 비어있는지 확인"""
        return self.head is None
    
    def append(self, data):
        """리스트 끝에 요소 추가"""
        new_node = Node(data)
        if not self.head:
            self.head = new_node
        else:
            current = self.head
            while current.next:
                current = current.next
            current.next = new_node
        self.size += 1
    
    def prepend(self, data):
        """리스트 시작에 요소 추가"""
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node
        self.size += 1</code></pre>
</div>
===SPLIT===
<h2>Linked List 구현 - 주요 메서드</h2>
<div class="example-box">
<h4>LinkedList 클래스 구현 (2/2)</h4>
<pre><code>    def insert(self, index, data):
        """특정 위치에 요소 삽입"""
        if index < 0 or index > self.size:
            raise IndexError("인덱스 범위 초과")
        
        if index == 0:
            self.prepend(data)
            return
        
        new_node = Node(data)
        current = self.head
        for _ in range(index - 1):
            current = current.next
        
        new_node.next = current.next
        current.next = new_node
        self.size += 1
    
    def remove(self, data):
        """첫 번째로 일치하는 요소 삭제"""
        if not self.head:
            return False
        
        if self.head.data == data:
            self.head = self.head.next
            self.size -= 1
            return True
        
        current = self.head
        while current.next:
            if current.next.data == data:
                current.next = current.next.next
                self.size -= 1
                return True
            current = current.next
        return False
    
    def find(self, data):
        """요소 검색 (인덱스 반환)"""
        current = self.head
        index = 0
        while current:
            if current.data == data:
                return index
            current = current.next
            index += 1
        return -1</code></pre>
</div>
===SPLIT===
<h2>Linked List 유틸리티 메서드</h2>
<h3>추가 기능과 편의 메서드</h3>
<div class="example-box">
<h4>유틸리티 메서드 구현</h4>
<pre><code>    def get(self, index):
        """특정 인덱스의 요소 반환"""
        if index < 0 or index >= self.size:
            raise IndexError("인덱스 범위 초과")
        
        current = self.head
        for _ in range(index):
            current = current.next
        return current.data
    
    def reverse(self):
        """리스트 역순으로 뒤집기"""
        prev = None
        current = self.head
        
        while current:
            next_node = current.next
            current.next = prev
            prev = current
            current = next_node
        
        self.head = prev
    
    def display(self):
        """리스트 내용 출력"""
        elements = []
        current = self.head
        while current:
            elements.append(str(current.data))
            current = current.next
        return " -> ".join(elements) + " -> None"
    
    def to_list(self):
        """Python 리스트로 변환"""
        result = []
        current = self.head
        while current:
            result.append(current.data)
            current = current.next
        return result</code></pre>
</div>
===SPLIT===
<h2>Linked List 활용 예제</h2>
<h3>실제 사용 시나리오</h3>
<div class="example-box">
<h4>LinkedList 사용 예제</h4>
<pre><code># LinkedList 생성 및 사용
ll = LinkedList()

# 요소 추가
ll.append(10)
ll.append(20)
ll.append(30)
print(ll.display())  # 10 -> 20 -> 30 -> None

# 시작에 추가
ll.prepend(5)
print(ll.display())  # 5 -> 10 -> 20 -> 30 -> None

# 특정 위치에 삽입
ll.insert(2, 15)
print(ll.display())  # 5 -> 10 -> 15 -> 20 -> 30 -> None

# 요소 검색
index = ll.find(20)
print(f"20의 위치: {index}")  # 20의 위치: 3

# 요소 삭제
ll.remove(15)
print(ll.display())  # 5 -> 10 -> 20 -> 30 -> None

# 리스트 역순
ll.reverse()
print(ll.display())  # 30 -> 20 -> 10 -> 5 -> None

# Python 리스트로 변환
python_list = ll.to_list()
print(python_list)  # [30, 20, 10, 5]

# 크기 확인
print(f"리스트 크기: {len(ll)}")  # 리스트 크기: 4</code></pre>
</div>
===SPLIT===
<h2>Linked List 변형</h2>
<h3>다양한 유형의 연결 리스트</h3>
<div class="grid-container-3">
<div class="data-card">
<h5>단일 연결 리스트</h5>
<p>각 노드가 다음 노드만 가리킴</p>
<p>가장 기본적인 형태</p>
<p>메모리 효율적</p>
<pre><code>class Node:
    def __init__(self, data):
        self.data = data
        self.next = None</code></pre>
</div>
<div class="data-card">
<h5>이중 연결 리스트</h5>
<p>각 노드가 이전/다음 노드 모두 가리킴</p>
<p>양방향 순회 가능</p>
<p>삭제 연산 효율적</p>
<pre><code>class DNode:
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None</code></pre>
</div>
<div class="data-card">
<h5>원형 연결 리스트</h5>
<p>마지막 노드가 첫 노드를 가리킴</p>
<p>순환 구조</p>
<p>라운드 로빈 등에 활용</p>
<pre><code>class CircularList:
    def __init__(self):
        self.head = None
        # tail.next = head</code></pre>
</div>
</div>
<div class="warning-box">
<h4>이중 연결 리스트 간단 구현</h4>
<pre><code>class DoublyLinkedList:
    def __init__(self):
        self.head = None
        self.tail = None
    
    def append(self, data):
        new_node = DNode(data)
        if not self.head:
            self.head = self.tail = new_node
        else:
            new_node.prev = self.tail
            self.tail.next = new_node
            self.tail = new_node
    
    def display_forward(self):
        current = self.head
        while current:
            print(current.data, end=" <-> ")
            current = current.next
        print("None")</code></pre>
</div>
===SPLIT===
<h2>시간 복잡도 분석</h2>
<h3>Linked List 연산의 효율성</h3>
<table>
<tr>
<th>연산</th>
<th>시간 복잡도</th>
<th>설명</th>
</tr>
<tr>
<td>접근 (Access)</td>
<td>O(n)</td>
<td>특정 인덱스까지 순차 탐색 필요</td>
</tr>
<tr>
<td>검색 (Search)</td>
<td>O(n)</td>
<td>최악의 경우 모든 노드 확인</td>
</tr>
<tr>
<td>삽입 - 시작</td>
<td>O(1)</td>
<td>Head 포인터만 변경</td>
</tr>
<tr>
<td>삽입 - 끝</td>
<td>O(n)</td>
<td>마지막 노드까지 이동 필요 (tail 있으면 O(1))</td>
</tr>
<tr>
<td>삽입 - 중간</td>
<td>O(n)</td>
<td>삽입 위치까지 탐색 + O(1) 삽입</td>
</tr>
<tr>
<td>삭제 - 시작</td>
<td>O(1)</td>
<td>Head 포인터만 변경</td>
</tr>
<tr>
<td>삭제 - 끝</td>
<td>O(n)</td>
<td>마지막 이전 노드 찾기 필요</td>
</tr>
<tr>
<td>삭제 - 중간</td>
<td>O(n)</td>
<td>삭제할 노드까지 탐색</td>
</tr>
</table>
<div class="formula">
공간 복잡도: O(n) - n개의 노드 저장
</div>
===SPLIT===
<h2>Linked List 문제 - LeetCode</h2>
<h3>실전 문제로 연습하기</h3>
<div class="box">
<h4>추천 LeetCode 문제</h4>
<table>
<tr>
<th>문제 번호</th>
<th>제목</th>
<th>난이도</th>
<th>핵심 개념</th>
</tr>
<tr>
<td>206</td>
<td>Reverse Linked List</td>
<td>Easy</td>
<td>포인터 조작, 역순 변환</td>
</tr>
<tr>
<td>21</td>
<td>Merge Two Sorted Lists</td>
<td>Easy</td>
<td>두 리스트 병합</td>
</tr>
<tr>
<td>141</td>
<td>Linked List Cycle</td>
<td>Easy</td>
<td>순환 감지 (Floyd's Algorithm)</td>
</tr>
<tr>
<td>876</td>
<td>Middle of the Linked List</td>
<td>Easy</td>
<td>Two Pointer 기법</td>
</tr>
<tr>
<td>83</td>
<td>Remove Duplicates from Sorted List</td>
<td>Easy</td>
<td>중복 제거</td>
</tr>
<tr>
<td>19</td>
<td>Remove Nth Node From End</td>
<td>Medium</td>
<td>Two Pointer, 끝에서 n번째</td>
</tr>
<tr>
<td>2</td>
<td>Add Two Numbers</td>
<td>Medium</td>
<td>수학 연산 구현</td>
</tr>
<tr>
<td>138</td>
<td>Copy List with Random Pointer</td>
<td>Medium</td>
<td>Deep Copy</td>
</tr>
</table>
</div>
</div>
`;
        const slidesArray = slidesHTML.split('===SPLIT===');
        const container = document.getElementById('slidesContainer');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const currentSlideSpan = document.getElementById('currentSlide');
        const totalSlidesSpan = document.getElementById('totalSlides');
        const pageInput = document.getElementById('pageInput');
        const jumpBtn = document.getElementById('jumpBtn');
        
        let currentSlide = 0;
        
        slidesArray.forEach((slideContent, index) => {
            const slideDiv = document.createElement('div');
            slideDiv.className = 'slide';
            slideDiv.innerHTML = slideContent.trim();
            container.appendChild(slideDiv);
        });
        
        const slides = document.querySelectorAll('.slide');
        totalSlidesSpan.textContent = slides.length;
        
        function showSlide(n) {
            slides.forEach(slide => slide.classList.remove('active'));
            
            if (n >= slides.length) {
                currentSlide = slides.length - 1;
            } else if (n < 0) {
                currentSlide = 0;
            } else {
                currentSlide = n;
            }
            
            slides[currentSlide].classList.add('active');
            currentSlideSpan.textContent = currentSlide + 1;
            
            prevBtn.disabled = currentSlide === 0;
            nextBtn.disabled = currentSlide === slides.length - 1;
            
            container.scrollTop = 0;
        }
        
        prevBtn.addEventListener('click', () => showSlide(currentSlide - 1));
        nextBtn.addEventListener('click', () => showSlide(currentSlide + 1));
        
        jumpBtn.addEventListener('click', () => {
            const page = parseInt(pageInput.value);
            if (page >= 1 && page <= slides.length) {
                showSlide(page - 1);
                pageInput.value = '';
            }
        });
        
        pageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                jumpBtn.click();
            }
        });
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' && !prevBtn.disabled) {
                prevBtn.click();
            } else if (e.key === 'ArrowRight' && !nextBtn.disabled) {
                nextBtn.click();
            }
        });
        
        showSlide(0);
    </script>
</body>
</html>